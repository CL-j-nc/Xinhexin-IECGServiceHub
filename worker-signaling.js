// 这是一个基本示例。在实际应用中，你需要更强大的会话管理、 // 安全性和可能的持久性。 const connectedClients = new Map(); // Map<conversationId, Set<WebSocket>> export default { async fetch(request, env) { const url = new URL(request.url); // 仅当路径为 /ws 时才升级到 WebSocket if (url.pathname === '/ws') { const { webSocket, response } = WebSocketPair.fromRequest(request); webSocket.accept(); webSocket.addEventListener('message', async (event) => { try { const message = JSON.parse(event.data); const { type, payload, conversationId } = message; if (!conversationId) { webSocket.send(JSON.stringify({ error: 'Missing conversationId' })); return; } if (!connectedClients.has(conversationId)) { connectedClients.set(conversationId, new Set()); } connectedClients.get(conversationId).add(webSocket); console.log(`[Worker] Received message for ${conversationId}:`, type, payload); // 将消息广播到同一会话中的所有其他客户端 connectedClients.get(conversationId).forEach((client) => { if (client !== webSocket && client.readyState === WebSocket.OPEN) { client.send(JSON.stringify({ type, payload, conversationId })); } }); } catch (err) { console.error('[Worker] WebSocket message error:', err); webSocket.send(JSON.stringify({ error: 'Invalid message format' })); } }); webSocket.addEventListener('close', () => { console.log('[Worker] WebSocket closed'); // 从所有会话集中移除客户端 connectedClients.forEach((clientsSet, conversationId) => { if (clientsSet.has(webSocket)) { clientsSet.delete(webSocket); if (clientsSet.size === 0) { connectedClients.delete(conversationId); } } }); }); webSocket.addEventListener('error', (err) => { console.error('[Worker] WebSocket error:', err); }); return response; } // 处理其他 HTTP 请求（例如，用于健康检查或静态资源） return new Response('Not a WebSocket upgrade request', { status: 400 }); }, };